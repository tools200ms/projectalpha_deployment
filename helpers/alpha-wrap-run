#!/bin/sh


[ -n "$PRETEND" ] && [[ $(echo "$PRETEND" | tr '[:upper:]' '[:lower:]') =~ ^y|yes|1|on$ ]] && \
        RUN="echo" || RUN=

[ -n "$DEBUG" ] && [[ $(echo "$DEBUG" | tr '[:upper:]' '[:lower:]') =~ ^y|yes|1|on$ ]] && \
        set -xe || set -e


function first_arg() {
  echo $1
}

function second_arg() {
  echo $2
}

function last_args() {
  if [ -n "$1" ]; then
    shift
  fi

  echo "$@"
}

readonly ONE_MIB=$(( 1024 * 1024 ))
readonly ONE_GIB=$(( 1024 * $ONE_MIB ))

readonly BOOT_FS_OFFSET=$(( 8192 * 512 ))

declare -A devices_dtb
declare -A devices_cpu

# arm:
devices_dtb["raspi0"]="alpine-standard/bcm2835-rpi-zero.dtb"
devices_cpu["raspi0"]="arm1176"

# aarch:
devices_dtb["raspi3b"]="raspios-bookworm-arm64/bcm2710-rpi-3-b.dtb"
devices_cpu["raspi3b"]="cortex-a53"


readonly DTB_LIB="/var/lib/alphawrap/dtb"
readonly BOOT_MNT_DIR="/mnt/img.boot"

#CACHE_DIR="/var/cache/pilinux"
readonly CACHE_DIR="/var/cache/alphawrap"
readonly DB_DIR="/var/cache/alphawrap/db"
readonly EXTSTORE_DIR="/var/cache/alphawrap/ext_storage"
readonly TEMP_DIR="/var/tmp"

readonly QEMU_MONITOR_UNIXSOCKET="/tmp/qemu-monitor"

readonly DEFAULT_DEVICE_MODEL="raspi3b"

# Global variables:
# From parameters:
_MODE=

_IMG_BOOT=0
_NO_PART_TABLE_MODE=-1

_DEV_MODEL=${DEFAULT_DEVICE_MODEL}
_MACHINE=$_DEV_MODEL

_IMG_FILE=
_KERNEL=vmlinuz
_INITRAMFS=

_NEW_CONTAINER=0
_CONTAINER_NAME=

_LIST_WITH_DETAILS=0

# Run-time globals
_LOBOOT_DEV=


function print_help() {
    cat <<EOF
Usage:
Creating container:
$(basename $0) --device|-d [raspi3b] <img file> --imgboot|-i y|n <kernel> <initramfs> --name|-n <name>

  --device|-d      - Model of the emulated device (default: '${DEFAULT_DEVICE_MODEL}').
  <img file>       - Path to image file to be mounted as 'mmcblk0'.
  --imgboot|-i y|n - If 'y' load <kernel> and <initramfs> from a boot
                     partition of the image file.
                     If 'n' load <kernel> and <initramfs> from file.
                     <kernel>    - Path to kernel, if '-i y' path within
                                   boot partition of the image file.
                                   If '-i n' path to kernel file that is
                                   located at host.
                     <initramfs> - Path to initramfs, if '-i y' path within
                                   boot partition of the image file.
                                   If '-i n' path to initramfs file that is
                                   located at host.
                     Initramfs is optional, if not provided emulated system
                     will boot with just kernel image. It means that kernel
                     must have all modules to mount root fs as well as to
                     access necessary devices such as disk controller.

                     Also, <kernel> path might be skiped, in this case default
                     '${_KERNEL}' is loaded from boot image file partition
                     (if '-i y'), or current directory of a local file system
                     (if '-i n'). In this case initramfs can't be used.

  --name|-n        - Create named container, in option '-n' is followed by
                     <name> container with a given name is created.
                     If only option '-n' is provided container with random name
                     is created, name of the container is displayed upon launch.

                     If option '-n' is not provided then temporary container is
                     created - it will be removed after machine is stopped.

Launching container:
$(basename $0) <container name>
  This will launch container that has been created from an image.


Listing containers:
$(basename $0) ls --full|-f
  ls - list all defined containers

Attachable (extstore) image operations:
$(basename $0) extstore [ls --full|-f] | [add <name|path> SIZE] | [eject]
  Container can have virtually attached external ("USB stick") storage.

  extstore ls  - list attachable images
    --full|-f  - list attachable images with details

  extstore add - add 'external' storage to machine, the storage will be
                 available as USB stick. Storage can be identified by a path,
                 or name. If identified by path, '$(basename $0)' is expecting
                 a file name. Indicated file will be attached to machine as a
                 storage device.
                 If name provided, '$(basename $0)' will search for an
                 attachable image in its internal storage system.

                 If storage exists, it will be attached to the machine.
                 In order to create storage, non existing image name or path
                 must be provided followed by a size. '$(basename $0)' will
                 create storage of a given size and attach it to the machine.

                 New storage is automatically initiated with zeros.
                 Default SIZE unit is MiB, SIZE can be postfixed by MiB, MB,
                 GiG, GB e.g.: 2GB

Initialization:
$(basename $0) init
  Create storage backends, databases etc. for $(basename $0)

EOF
}

# sd-card size must be of power 2, e.g.:
# 512MiB, 1GiB, 2GiB, 4GiB ...
# Append extra 'zeros' to an end of an
# image file to ensure that its size is
# exactly 2^<power> bites.
function prepare_mmc_imgfile() {
  local IMAGE_PATH="$1"
  local CACHE_FILE="$2"

  if [ ! -f "$CACHE_FILE" ] || [ ! -s "$CACHE_FILE" ] ; then
    # if file does not exists, or is a zero size copy image
    $RUN cp "$IMAGE_PATH" $CACHE_FILE
  fi
  # else, if file already exists veriry size

  CUR_SIZE=$(first_arg $(du -sb $IMAGE_PATH))

  POW=$(( 256*1024*1024 ))

  while [ $POW -lt $CUR_SIZE ]; do
    POW=$(($POW*2))
    #echo $POW
  done

  REM_SIZE_TOPOW=$(($POW - $CUR_SIZE))

  # if zero file is of a proper size already

  if [ $REM_SIZE_TOPOW -ne 0 ]; then
    #echo "Appending file with extra 'zeros' to reach size that is a power of 256 MiB (requirment for SD cards)"
    #echo "Appending by: $REM_SIZE_TOPOW bytes"
    #echo "Final size: $(($REM_SIZE_TOPOW + $CUR_SIZE)) bytes"

    # make file size to be multiple of MB:
    TAIL=$(( ($REM_SIZE_TOPOW % $ONE_MIB) ))

    # init is in bytes
    if [ $TAIL -ne 0 ]; then
      $RUN dd bs=1 seek=$CUR_SIZE if=/dev/zero of=$CACHE_FILE count=$TAIL
    fi

    # change units to MiB
    CUR_SIZE=$(( ($CUR_SIZE + $TAIL) / $ONE_MIB ))
    TAIL=$(($REM_SIZE_TOPOW / $ONE_MIB))

    if [ $TAIL -ne 0 ]; then
      $RUN dd bs=$ONE_MIB seek=$CUR_SIZE if=/dev/zero of=$CACHE_FILE count=$TAIL
    fi
  fi
}

function prepare_usbstick() {
  local PATH=$1
  local SIZE_MB=$2

  $RUN /usr/bin/dd bs=$ONE_MIB count=${SIZE_MB} if="/dev/zero" of="${PATH}"
}

function mount_boot() {
  local WORK_IMG=$1

  # Get available loop device, normally '/dev/loop0'
  if [ -z "$RUN" ]; then
    _LOBOOT_DEV=$(losetup -f)
  else
    _LOBOOT_DEV="/dev/loop0dummy"
  fi
  # Create device for mounting partition that will be used as 'boot'
  $RUN losetup $_LOBOOT_DEV $WORK_IMG
  $RUN partprobe -s $_LOBOOT_DEV

  # mount first partition, or if no partition table mount filesystem directly
  if [ -e ${_LOBOOT_DEV}p1 ]; then
    $RUN mount ${_LOBOOT_DEV}p1 $BOOT_MNT_DIR -o ro
    _NO_PART_TABLE_MODE=0
  else
    $RUN mount ${_LOBOOT_DEV} $BOOT_MNT_DIR -o ro
    _NO_PART_TABLE_MODE=1
  fi
}

function umount_boot() {
  $RUN umount ${BOOT_MNT_DIR}
  $RUN losetup -d ${_LOBOOT_DEV}
}

# Check environment:
function check_environment() {
  $RUN mkdir -p ${CACHE_DIR} ${DB_DIR} ${TEMP_DIR} ${EXTSTORE_DIR}
}

# Command line parsing functions:

function set_flag_imgboot() {
  if [ -z "$2" ] && [ "yes_no" == "$2" ]; then
    _IMG_BOOT=$1
  fi
}

function set_create_container() {

  if [ -z "$2" ]; then
    if [ -z "${_CONTAINER_NAME}" ]; then
      _CONTAINER_NAME="$(shuf -n 1 ./verbs.txt)-$(shuf -n 1 ./nouns.txt)"
    fi

    _NEW_CONTAINER=1
  fi
}


function parse_yes_no() {
  if [ -z "$1" ]; then
    echo "Empty argument (fix code?)"
    exit 55
  fi

  if [[ $(echo "$1" | tr '[:upper:]' '[:lower:]') =~ ^y|yes|1|on$ ]] ; then
    return 1
  elif [[ $(echo "$1" | tr '[:upper:]' '[:lower:]') =~ ^n|no|0|off$ ]] ; then
    return 0
  else
    echo "Correct option is one of: yes, y, on, 1 or no, n, 0, off"
    exit 3
  fi
}

function parse_devmodel_name() {
  if [[ ! "$1" =~ ^([a-zA-Z0-9-]){1,128}$ ]]; then
    echo "Illegal machine (device) name"
    exit 3
  fi

  MACHINE=$(qemu-system-aarch64 -machine help | grep "^$1[[:space:]].*")

  if [ -z "$MACHINE" ]; then
    echo "Machine (device) has not been found: $1"
    exit 3
  fi

  _MACHINE=$(first_arg $MACHINE)
  echo "Loading: $_MACHINE"
}

function parse_imgfile_path() {
  if [ ! -f "$1" ]; then
    echo "Provide path to an existing file"
    exit 3
  fi

  _IMG_FILE=$(realpath "$1")
}

function parse_kernel_name() {
  if [[ ! "$1" =~ ^([a-zA-Z0-9_/-]){1,128}$ ]]; then
    echo "Illegal kernel name"
    exit 3
  fi

  _KERNEL=$1
}

function parse_initramfs_name() {
  if [[ ! "$1" =~ ^([a-zA-Z0-9_/-]){1,128}$ ]]; then
    echo "Illegal initramfs name"
    exit 3
  fi

  _INITRAMFS=$1
}

function parse_container_name() {
  if [[ ! "$1" =~ ^([_a-zA-Z0-9-]){1,128}$ ]]; then
    echo "Illegal name"
    exit 3
  fi

  _CONTAINER_NAME=$1
}

_EXTSTORAGE_MODE=
_EXTSTORAGE_REF=
_EXTSTORAGE_REF_ISINTERNAL=
_EXTSTORAGE_SIZE=

function parse_extstorage() {
  # validation is in: set_validate_extstore_add
  _EXTSTORAGE_REF=$1
}

function parse_size() {
  local input="$1"
  local number
  local unit
  local result

  # Use regular expression to match the number and unit (MB, GB, MiB, GiB)
  if [[ "$input" =~ ^([0-9]+(\.[0-9]+)?)\ ?(MB|GB|MiB|GiB)$ ]]; then
    number="${BASH_REMATCH[1]}"
    unit="${BASH_REMATCH[3]}"

    case "$unit" in
      MB)
        result=$(echo "scale=2; $number * 0.953674" | bc)
      ;;
      GB)
        result=$(echo "scale=2; $number * 953.674" | bc)
      ;;
      MiB)
        result="$number"
      ;;
      GiB)
        result=$(echo "scale=2; $number * 1024" | bc)
      ;;
    esac

    # Round up to the nearest integer using awk
    _EXTSTORAGE_SIZE=$(echo "$result" | awk '{print ($1 == int($1)) ? $1 : int($1)+1}')
    echo "$_EXTSTORAGE_SIZE"
  else
    echo "Invalid input. Please provide a number followed by MB, GB, MiB, or GiB."
    return 1
  fi
}

function set_validate_extstore_add() {
  loal FILENAME=

  if [ -n "${2}" ]; then
    # skipp "per parameter" setter call
    # proceed in the case of "finale" call (when all variables are ready)
    return
  fi

  if [[ "${_EXTSTORAGE_REF}" =~ ^([a-zA-Z0-9_/-\.]){1,1024}$ ]] ; then
    FILENAME="${_EXTSTORAGE_REF}"
    _EXTSTORAGE_REF_ISINTERNAL=0
    # probe if it's a file name:
    if [ -f "${FILENAME}" ]; then
      if [ -n "${_EXTSTORAGE_SIZE}" ]; then
        echo "Image already exists, excess size declaration, exiting"
        exit 5
      fi

      return
    fi
  fi

  if [[ "${_EXTSTORAGE_REF}" =~ ^([a-zA-Z0-9_-]){1,128}$ ]]; then
    FILENAME=${EXTSTORAGE_DIR}/${_EXTSTORAGE_REF}.img
    _EXTSTORAGE_REF_ISINTERNAL=1

    if [ -f "${FILENAME}" ]; then
      if [ -n "${_EXTSTORAGE_SIZE}" ]; then
        echo "Image already exists, excess size declaration, exiting"
        exit 5
      fi

      return
    fi
  fi

  if [ -z "${FILENAME=}" ]; then
    echo "Incorrect image file path or name"
    exit 4
  fi

  # create image if size was given:

  if [ -z "${_EXTSTORAGE_SIZE}" ]; then
    echo "No size has been provided"
    exit 4
  fi

  prepare_usbstick "${FILENAME}" ${_EXTSTORAGE_SIZE}
}

# Parser 'global' variables
# "parse_now", "param_chain" and "setter_fn" has been defined to handle
# variable parameter "chains"
# Once when 'option' has been identified such as 'ls', '--name'
# variables: 'parse_now', 'parse_chain' and 'setter_fn'
# are used to handle variable argument length parsing
# Thus, some options might be optional making command line
# more user friendly.
# parse_now is the
setter_fn=
param_chain=

# Return value:
#     1 - argument has been read
#     0 - argument can't be interpreted by current setter and parser,
#         continue parsing
function parse() {
  local opt=$1
  local _parse_now=$(first_arg $param_chain)

  if [ -z "$_parse_now" ]; then
    return 0
  fi

  param_chain=$(last_args $param_chain)

  if [[ "${_parse_now:0:1}" == '?' ]]; then
    opt_param=1
    _parse_now="${_parse_now:1}"
  else
    opt_param=0
  fi

  if [[ "${opt:0:1}" == "-" ]]; then
    if [ $opt_param -eq 0 ]; then
      echo "Illegal parameter (starting with '-')"
      exit 1
    else
      if [ -n "$setter_fn" ]; then
        eval "set_$setter_fn"
        setter_fn=
      fi

      _parse_now=
      param_chain=

      return 0
    fi
  fi

  if [ -n "$opt" ]; then
    eval "parse_$_parse_now $opt"
    res_code=$?

    if [ -n "$setter_fn" ]; then
      eval "set_$setter_fn" $res_code $_parse_now
      #setter_fn=
    fi
  else
    res_code=0
  fi

  if [ -n "$setter_fn" ] && [ -z "$param_chain" ]; then
    # final seter call
    eval "set_$setter_fn"
    setter_fn=
  fi

  #_parse_now=$(first_arg $param_chain)
  #param_chain=$(last_args $param_chain)

  return 1
}

function root_required() {
  if [ -z "$RUN" ] && [ $(id -u) -ne 0 ]; then
    echo "Run it as root"
    echo "    sorry for disturbing safe realm"
    exit 0
  fi
}

function lock_mode() {
  local mode=$1

  if [ -z "${_MODE}" ]; then
    _MODE=${mode}
  else [ "${_MODE}" != ${mode} ]
    echo "Syntax error."
    exit 2
  fi
}

function has_mode() {
  if [ -n "${_MODE}" ] && [ "${_MODE}" == "$1" ]; then
    # True
    return 0
  fi

  # False
  return 1
}


# parse argument loop
for opt in "$@"; do
  if ! parse $opt; then
    # take next argument
    continue
  fi

  case $opt in
    --device|-d)
      lock_mode "image"
      param_chain="devmodel_name"
    ;;
    --imgboot|-i)
      lock_mode "image"

      setter_fn="flag_imgboot"
      param_chain="yes_no ?kernel_name ?initramfs_name"
    ;;
    --name|-n)
      param_chain="?container_name"
      setter_fn="create_container"
    ;;
    extstorage)
      lock_mode "extstore"
    ;;
    add)
      lock_mode "extstore"
      _EXTSTORAGE_MODE="add"

      #_parse_now=""
      param_chain="?size"
      setter_fn="validate_extstore_add"
    ;;
    ls)
      if $(has_mode "extstore"); then
        _EXTSTORAGE_MODE="ls"
      else
        lock_mode "list"
      fi
    ;;
    --full|-f)
      _LIST_WITH_DETAILS=1
    ;;
    --help|-h)
      print_help
      exit 0
    ;;
    init)
      lock_mode "init"
    ;;
    *)
      # probe:
      if [ -f "$opt" ]; then
        parse_imgfile_path $opt
      else
        parse_container_name $opt
      fi
    ;;
  esac
done

# parse remaining arguments if exists
parse || true

# determinate operation mode:
if [ -n "$_IMG_FILE" ]; then
  _MODE="image"
elif [ -n "$_CONTAINER_NAME" ]; then
  _MODE="container"
  # load settings
fi

case $_MODE in
  image)
    root_required
    check_environment $_MODE

    echo "Run image... $_MACHINE $_IMG_FILE $_KERNEL $_INITRAMFS"
    if [ $_NEW_CONTAINER -eq 1 ]; then
      echo "Creating continer: $_CONTAINER_NAME"

      CONT_FILE=${CACHE_DIR}/${_CONTAINER_NAME}.img
      if [ -f $CONT_FILE ]; then
        echo "Continer already exists, launch container instead"
        exit 4
      fi

      prepare_mmc_imgfile $_IMG_FILE $CONT_FILE

      mkdir -p $DB_DIR/$_CONTAINER_NAME
      cat <<EOF > $DB_DIR/${_CONTAINER_NAME}/config.txt
# file auto-generated
container $_CONTAINER_NAME
device    $_MACHINE
kernel    $_KERNEL
initramfs $_INITRAMFS
imgboot   $_IMG_BOOT

rootimg   $_IMG_FILE
cdate     $(date)
EOF
    else
      # running tempolary container
      TEMP_CACHE_FILE=$(mktemp --tmpdir=$TEMP_DIR --suffix=-container.img)
      _CONTAINER_NAME=$(basename ${TEMP_CACHE_FILE})

      prepare_mmc_imgfile $_IMG_FILE $TEMP_CACHE_FILE
      CONT_FILE=$TEMP_CACHE_FILE
    fi

    if [ $_IMG_BOOT -eq 1 ]; then
      # mount boot partition
      mount_boot $CONT_FILE

      _KERNEL=${BOOT_MNT_DIR}/${_KERNEL}

      if [ -f ${BOOT_MNT_DIR}/cmdline.txt ]; then
        CMDLINE_FILE_PATH=${BOOT_MNT_DIR}/cmdline.txt
      fi

      if [ -n "${_INITRAMFS}" ]; then
        _INITRAMFS=$BOOT_MNT_DIR/$_INITRAMFS
      fi
    fi

    # installation
    if [ $_NEW_CONTAINER -eq 1 ]; then
      $RUN cp $_KERNEL $DB_DIR/$_CONTAINER_NAME/
      _KERNEL=${DB_DIR}/${_CONTAINER_NAME}/$(basename ${_KERNEL})

      if [ -n "${CMDLINE_FILE_PATH}" ]; then
        $RUN cp ${CMDLINE_FILE_PATH} ${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt
        CMDLINE_FILE_PATH=${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt
      fi

      if [ -n "$_INITRAMFS" ]; then
        $RUN cp $_INITRAMFS $DB_DIR/$_CONTAINER_NAME/
        _INITRAMFS=$DB_DIR/$_CONTAINER_NAME/$(basename ${_INITRAMFS})
      fi
    fi

    if [ $_NEW_CONTAINER -eq 1 ] && [ $_IMG_BOOT -eq 1 ]; then
      # umount boot partition
      umount_boot
    fi

    # create external storage for container:
    prepare_usbstick ${EXTSTORE_DIR}/${_CONTAINER_NAME}-01.img 512
  ;;

  container)
    root_required
    check_environment $_MODE

    echo "Run container... $_MACHINE $_IMG_FILE $_KERNEL $_INITRAMFS"

    _MACHINE=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^device'))
    _IMG_BOOT=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^imgboot'))
    _KERNEL=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^kernel'))
    _INITRAMFS=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^initramfs'))

    _KERNEL=$DB_DIR/${_CONTAINER_NAME}/$_KERNEL

    if [ -n "$_INITRAMFS" ]; then
      _INITRAMFS=$DB_DIR/${_CONTAINER_NAME}/$_INITRAMFS
    fi

    CONT_FILE=${CACHE_DIR}/${_CONTAINER_NAME}.img

    if [ $_IMG_BOOT -eq 1 ]; then
      mount_boot ${CONT_FILE}

      if ! $(cmp $BOOT_MNT_DIR/$(basename ${_KERNEL}) $_KERNEL); then
        # update kernel:
        $RUN cp $BOOT_MNT_DIR/$(basename ${_KERNEL}) ${_KERNEL}
      fi

      if [ -n "${_INITRAMFS}" ] && ! $(cmp $BOOT_MNT_DIR/$(basename ${_INITRAMFS}) ${_INITRAMFS}); then
        $RUN cp $BOOT_MNT_DIR/$(basename ${_INITRAMFS}) ${_INITRAMFS}
      fi

      umount_boot
    fi
  ;;
  list)
    check_environment $_MODE

    if [ $_LIST_WITH_DETAILS -eq 1 ]; then
      ls -lh $DB_DIR
    else
      ls $DB_DIR
    fi

    exit 0
  ;;
  init)
    root_required
    echo "Initializing $(basename $0) database and storage"

    check_environment $_MODE

    exit 0
  ;;
  *)
    # if undefined mode print help:
    print_help
    exit 2
  ;;
esac

# Test and run:

# At this point in the case of '--imgboot y' image boot partition is
# mounted and ${_KERNEL} and ${_INITRAMFS} (if defined) is a path to
# file within mounted boot partition.
# Therefore below code tests for kernel and initramfs existsnce
# regardless of '--imgboot' option.

if [ -z $RUN ] && [ ! -f ${_KERNEL} ]; then
  echo "Can't find kernel: ${_KERNEL}"
  exit 3
fi

if [ -z $RUN ] && [ -n "${_INITRAMFS}" ] && [ ! -f "${_INITRAMFS}" ]; then
  echo "Initramfs file does not exits or it's not permited to acces it."
  exit 3
fi

M_CPU=${devices_cpu[${_MACHINE}]}
M_DTB=${devices_dtb[${_MACHINE}]}

DTB_FILE=${DTB_LIB}/${M_DTB}

if [ ! -f "${DTB_FILE}" ]; then
  echo "DTB file has not been found: ${DTB_FILE}"
  exit 3
fi

#   -chardev socket,id=com0,path=/tmp/builder1.sock,server=on,wait=off \
# mount /dev/loop1p2 /mnt/dir
# cd /mnt/dir
# rm ./systemd/system/multi-user.target.wants/userconfig.service
#

# PCI required:
#   -virtfs local,path=./share,mount_tag=host0,security_model=passthrough,id=host0 \

# looks like system does not create /dev/ttyAMA0 device,
# as a result only boot messages are print, can't login
# All (Ethernet and mass storage) USB devices running at USB 1.1 speed
# slow, but works well and no rush
function run() {
  KERNEL_LINE="-kernel ${_KERNEL}"

  # add initrd if its used
  if [ -n "${_INITRAMFS}" ]; then
    KERNEL_LINE="${KERNEL_LINE} -initrd ${_INITRAMFS}"
  fi

  if [ ! -f "${CMDLINE_FILE_PATH}" ] && [ -f "${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt" ]; then
    CMDLINE_FILE_PATH=${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt

    KERNEL_PARAMS=$(tail -n 1 "${CMDLINE_FILE_PATH}")
  else
    # default kernel parameters
    KERNEL_PARAMS="console=tty1 console=ttyAMA0 root=/dev/mmcblk0p2 rw"
    # console=ttyAMA1

    # Set parameters
    if [ ${_NO_PART_TABLE_MODE} -eq 0 ]; then
      KERNEL_PARAMS="${KERNEL_PARAMS} root=/dev/mmcblk0p2 rw"
    else
      KERNEL_PARAMS="${KERNEL_PARAMS} modules=loop,squashfs,sd-mod,usb-storage"
    fi
  fi

  $RUN /usr/bin/qemu-system-aarch64 \
    -M ${_MACHINE} \
    -cpu ${M_CPU} -m 1024 \
    -monitor unix:$QEMU_MONITOR_UNIXSOCKET,server,nowait \
    -serial pty \
    ${KERNEL_LINE} -append "${KERNEL_PARAMS}" \
    -drive id=sysdrive,if=none,format=raw,file=${CONT_FILE} \
    -device sd-card,drive=sysdrive \
    -usb \
    -device usb-kbd,bus=usb-bus.0 \
    -netdev user,id=net0,hostfwd=tcp::15022-:22 \
    -device usb-net,bus=usb-bus.0,netdev=net0 \
    -dtb ${DTB_FILE} \
    -rtc base=localtime \
    -name "$_MACHINE emulator"

    #     -drive id=imgout0,if=none,format=raw,file="${EXTSTORE_DIR}/${_CONTAINER_NAME}-01.img" \
    #      -device usb-storage,bus=usb-bus.0,drive=imgout0 \
}

function insert_usbstick() {
  local PATH=$1

  nc -U $QEMU_MONITOR_UNIXSOCKET -q 0 <<EOF
info usb
EOF
#  drive_add 0 if=none,id=usbdrive1,format=raw,file=$PATH
#  device_add usb-storage,drive=usbdrive1,bus=usb-bus.0

  # do stuff

  #device_del usbdrive1
}

run

if [ -n "$TEMP_CACHE_FILE" ] && [ -e "$TEMP_CACHE_FILE" ]; then
  $RUN rm "$TEMP_CACHE_FILE"
  $RUN rm ${EXTSTORE_DIR}/${_CONTAINER_NAME}-01.img

  if [ $_IMG_BOOT -eq 1 ]; then
    $RUN umount_boot
  fi
fi


exit 0

#!/bin/sh


[ -n "$PRETEND" ] && [[ $(echo "$PRETEND" | tr '[:upper:]' '[:lower:]') =~ ^y|yes|1|on$ ]] && \
        RUN="echo" || RUN=

[ -n "$DEBUG" ] && [[ $(echo "$DEBUG" | tr '[:upper:]' '[:lower:]') =~ ^y|yes|1|on$ ]] && \
        set -xe || set -e


function first_arg() {
  echo $1
}

function second_arg() {
  echo $2
}

function last_args() {
  if [ -n "$1" ]; then
    shift
  fi

  echo "$@"
}

readonly ONE_MIB=$(( 1024 * 1024 ))
readonly ONE_GIB=$(( 1024 * $ONE_MIB ))

readonly BOOT_FS_OFFSET=$(( 8192 * 512 ))

declare -A devices_dtb
declare -A devices_cpu

# arm:
devices_dtb["raspi0"]="alpine-standard/bcm2835-rpi-zero.dtb"
devices_cpu["raspi0"]="arm1176"

# aarch:
devices_dtb["raspi3b"]="raspios-bookworm-arm64/bcm2710-rpi-3-b.dtb"
devices_cpu["raspi3b"]="cortex-a53"


readonly DTB_LIB="/var/lib/alphawrap/dtb"
readonly BOOT_MNT_DIR="/mnt/img.boot"

#CACHE_DIR="/var/cache/pilinux"
readonly CACHE_DIR="/var/cache/alphawrap"
readonly DB_DIR="/var/cache/alphawrap/db"
readonly EXTSTORE_DIR="/var/cache/alphawrap/ext_storage"
readonly TEMP_DIR="/var/tmp"

readonly QEMU_MONITOR_UNIXSOCKET="/tmp/qemu-monitor"

$RUN mkdir -p ${CACHE_DIR} ${DB_DIR} ${TEMP_DIR} ${EXTSTORE_DIR}

DEFAULT_DEVICE_MODEL="raspi3b"

function print_help() {
    cat <<EOF
Launch VM:
$(basename $0) --device|-d [raspi3b] <img file> --imgboot|-i y|n <kernel> <initramfs> --new|-n <name>

  --device|-d - model of the emulated device (default: '$DEFAULT_DEVICE_MODEL')
  <img file>  - path to image file to be mounted as mmc
  --imgboot|-i y|n - if 'y' find <kernel> and <initramfs> in a boot
                      partition of the image file.
                      if 'n' <kernel> and <initramfs> point to an external
                      files
  --new|-n - persistent, create new container, it's name will be returned

Launch VM based on created container:
$(basename $0) <container name or id>

List containers:
$(basename $0) ls --full|-f
  ls - list of continers

List attachable images:
$(basename $0) extstorage [ls --full|-f] | [add <name|path> SIZE]
  extstorage ls - list attachable images
    --full|-f   - list attachable images with detail

  extstorage add - add attachable storage to machine, the storage will be avaliable as USB stick.
                   Storage can be identified by path, or name, if identified by path, $(basename $0)
                   is expecting file name. Indicated file will be attached to machine as a storage device.
                   If name provided, $(basename $0) will search for image in its internel storage system.

                   If storage exists, it will be attached to the machine. In order to create storage, non
                   existing image name or path must be provided followed by size. $(basename $0) will create
                   sorage of a given size and attach it to machine.
                   Storage is initiated with zeros.

EOF
}

# sd-card size must be of power 2, e.g.:
# 512MiB, 1GiB, 2GiB, 4GiB ...
# Append extra 'zeros' to an end of an
# image file to ensure that its size is
# exactly 2^<power> bites.
function prepare_mmc_imgfile() {
  local IMAGE_PATH="$1"
  local CACHE_FILE="$2"

  if [ ! -f "$CACHE_FILE" ] || [ ! -s "$CACHE_FILE" ] ; then
    # if file does not exists, or is a zero size copy image
    $RUN cp "$IMAGE_PATH" $CACHE_FILE
  fi
  # else, if file already exists veriry size

  CUR_SIZE=$(first_arg $(du -sb $IMAGE_PATH))

  POW=$(( 256*1024*1024 ))

  while [ $POW -lt $CUR_SIZE ]; do
    POW=$(($POW*2))
    #echo $POW
  done

  REM_SIZE_TOPOW=$(($POW - $CUR_SIZE))

  # if zero file is of a proper size already

  if [ $REM_SIZE_TOPOW -ne 0 ]; then
    #echo "Appending file with extra 'zeros' to reach size that is a power of 256 MiB (requirment for SD cards)"
    #echo "Appending by: $REM_SIZE_TOPOW bytes"
    #echo "Final size: $(($REM_SIZE_TOPOW + $CUR_SIZE)) bytes"

    # make file size to be multiple of MB:
    TAIL=$(( ($REM_SIZE_TOPOW % $ONE_MIB) ))

    # init is in bytes
    if [ $TAIL -ne 0 ]; then
      $RUN dd bs=1 seek=$CUR_SIZE if=/dev/zero of=$CACHE_FILE count=$TAIL
    fi

    # change units to MiB
    CUR_SIZE=$(( ($CUR_SIZE + $TAIL) / $ONE_MIB ))
    TAIL=$(($REM_SIZE_TOPOW / $ONE_MIB))

    if [ $TAIL -ne 0 ]; then
      $RUN dd bs=$ONE_MIB seek=$CUR_SIZE if=/dev/zero of=$CACHE_FILE count=$TAIL
    fi
  fi
}

function prepare_usbstick() {
  local PATH=$1
  local SIZE_MB=$2

  $RUN /usr/bin/dd bs=$ONE_MIB count=${SIZE_MB} if="/dev/zero" of="${PATH}"
}

function mount_boot() {
  local WORK_IMG=$1

  # Get available loop device, normally '/dev/loop0'
  if [ -z "$RUN" ]; then
    _LOBOOT_DEV=$(losetup -f)
  else
    _LOBOOT_DEV="/dev/loop0dummy"
  fi
  # Create device for mounting partition that will be used as 'boot'
  $RUN losetup $_LOBOOT_DEV $WORK_IMG
  $RUN partprobe -s $_LOBOOT_DEV

  # mount first partition, or if no partition table mount filesystem directly
  if [ -e ${_LOBOOT_DEV}p1 ]; then
    $RUN mount ${_LOBOOT_DEV}p1 $BOOT_MNT_DIR -o ro
    _NO_PART_TABLE_MODE=0
  else
    $RUN mount ${_LOBOOT_DEV} $BOOT_MNT_DIR -o ro
    _NO_PART_TABLE_MODE=1
  fi
}

function umount_boot() {
  $RUN umount ${BOOT_MNT_DIR}
  $RUN losetup -d ${_LOBOOT_DEV}
}

# Image, Container, list
_MODE=

_IMG_BOOT=0
_NO_PART_TABLE_MODE=-1

_DEV_MODEL=$DEFAULT_DEVICE_MODEL
_MACHINE=$_DEV_MODEL

_IMG_FILE=
_KERNEL=vmlinuz
_INITRAMFS=

_NEW_CONTAINER=0
_CONTAINER_NAME=

_LIST_WITH_DETAILS=0

_LOBOOT_DEV=

function set_flag_imgboot() {
  _IMG_BOOT=$1
}

function set_create_container() {
  _NEW_CONTAINER=1

  if [ -z "$_CONTAINER_NAME" ]; then
    _CONTAINER_NAME="$(shuf -n 1 ./verbs.txt)-$(shuf -n 1 ./nouns.txt)"
  fi
}


function parse_yes_no() {
  if [ -z "$1" ]; then
    echo "Empty argument (fix code?)"
    exit 55
  fi

  if [[ $(echo "$1" | tr '[:upper:]' '[:lower:]') =~ ^y|yes|1|on$ ]] ; then
    return 1
  elif [[ $(echo "$1" | tr '[:upper:]' '[:lower:]') =~ ^n|no|0|off$ ]] ; then
    return 0
  else
    echo "Correct option is one of: yes, y, on, 1 or no, n, 0, off"
    exit 3
  fi
}

function parse_devmodel_name() {
  if [[ ! "$1" =~ ^([a-zA-Z0-9-]){1,128}$ ]]; then
    echo "Illegal machine (device) name"
    exit 3
  fi

  MACHINE=$(qemu-system-aarch64 -machine help | grep "^$1[[:space:]].*")

  if [ -z "$MACHINE" ]; then
    echo "Machine (device) has not been found: $1"
    exit 3
  fi

  _MACHINE=$(first_arg $MACHINE)
  echo "Loading: $_MACHINE"
}

function parse_imgfile_path() {
  if [ ! -f "$1" ]; then
    echo "Provide path to an existing file"
    exit 3
  fi

  _IMG_FILE=$(realpath "$1")
}

function parse_kernel_name() {
  if [[ ! "$1" =~ ^([a-zA-Z0-9_/-]){1,128}$ ]]; then
    echo "Illegal kernel name"
    exit 3
  fi

  _KERNEL=$1
}

function parse_initramfs_name() {
  if [[ ! "$1" =~ ^([a-zA-Z0-9_/-]){1,128}$ ]]; then
    echo "Illegal initramfs name"
    exit 3
  fi

  _INITRAMFS=$1
}

function parse_container_name() {
  if [[ ! "$1" =~ ^([_a-zA-Z0-9-]){1,128}$ ]]; then
    echo "Illegal name"
    exit 3
  fi

  _CONTAINER_NAME=$1
}

_EXTSTORAGE_REF=
_EXTSTORAGE_SIZE=

function parse_extstorage() {
  _EXTSTORAGE_REF=$1
}

function parse_size() {
  local input="$1"
  local number
  local unit
  local result

  # Use regular expression to match the number and unit (MB, GB, MiB, GiB)
  if [[ "$input" =~ ^([0-9]+(\.[0-9]+)?)\ ?(MB|GB|MiB|GiB)$ ]]; then
    number="${BASH_REMATCH[1]}"
    unit="${BASH_REMATCH[3]}"

    case "$unit" in
      MB)
        result=$(echo "scale=2; $number * 0.953674" | bc)
      ;;
      GB)
        result=$(echo "scale=2; $number * 953.674" | bc)
      ;;
      MiB)
        result="$number"
      ;;
      GiB)
        result=$(echo "scale=2; $number * 1024" | bc)

      ;;
    esac

    # Round up to the nearest integer using awk
    _EXTSTORAGE_SIZE=$(echo "$result" | awk '{print ($1 == int($1)) ? $1 : int($1)+1}')
    echo "$_EXTSTORAGE_SIZE"
  else
    echo "Invalid input. Please provide a number followed by MB, GB, MiB, or GiB."
    return 1
  fi
}

set_validate_extstor_add() {
  loal FILENAME=

  if [[ "$_EXTSTORAGE_REF" =~ ^([a-zA-Z0-9_/-]){1,1024}.img$ ]] ; then
    FILENAME=$_EXTSTORAGE_REF
  elif [[ "$_EXTSTORAGE_REF" =~ ^([a-zA-Z0-9_-]){1,128}$ ]] ; then
    FILENAME=${EXTSTORAGE_DIR}/${_EXTSTORAGE_REF}.img
  fi

  if [ ! -f "$_EXTSTORAGE_REF" ]; then
    if
    $EXTSTORAGE_DIR/
  fi
}

_parse_now=
setter_fn=
param_chain=

# Return value:
#     1 - argument has been read
#     0 - argument can't be interpreted by current setter and parser,
#         continue parsing
function parse() {
  local opt=$1

  if [ -n "$_parse_now" ]; then
    if [[ "${_parse_now:0:1}" == '?' ]]; then
      opt_param=1
      _parse_now="${_parse_now:1}"
    else
      opt_param=0
    fi

    if [[ "${opt:0:1}" == "-" ]]; then
      if [ $opt_param -eq 0 ]; then
        echo "Illegal parameter (starting with '-')"
        exit 1
      else
        _parse_now=
        setter_fn=
        param_chain=
        #eval "parse_$_parse_now"
        return 0
      fi
    fi

    if [ -n "$opt" ]; then
      eval "parse_$_parse_now $opt"
      res_code=$?
    else
      res_code=0
    fi

    if [ -n "$setter_fn" ]; then
      eval "set_$setter_fn" $res_code $parse_now
      setter_fn=
    fi

    _parse_now=$(first_arg $param_chain)
    param_chain=$(last_args $param_chain)

    return 1
  fi

  return 0
}

function root_required() {
  if [ -z "$RUN" ] && [ $(id -u) -ne 0 ]; then
    echo "Run it as root"
    echo "    sorry for disturbing safe realm"
    exit 0
  fi
}


for opt in "$@"; do
  if ! parse $opt; then
    # take next argument
    continue
  fi

  case $opt in
    --device|-d)
      _parse_now="devmodel_name"
    ;;
    --imgboot|-i)
      _parse_now="yes_no"
      setter_fn="flag_imgboot"
      param_chain="?kernel_name ?initramfs_name"
    ;;
    --new|-n)
      _parse_now="?container_name"
      setter_fn="create_container"
    ;;
    extstorage)
      _MODE="extstorage"
    ;;
    add)
      if [ "$_MODE" == "extstorage" ];
        _parse_now="?size"
        setter_fn="validate_extstor_add"
      else
        exit 2
      fi
    ;;
    ls)
      _MODE="list"
    ;;
    --full|-f)
      _LIST_WITH_DETAILS=1
    ;;
    --help|-h)
      print_help
      exit 0
    ;;
    *)
      # probe:
      if [ -f "$opt" ]; then
        parse_imgfile_path $opt
      else
        parse_container_name $opt
      fi
    ;;
  esac
done

# parse remaining arguments if exists
parse || true

# determinate operation mode:
if [ -n "$_IMG_FILE" ]; then
  _MODE="image"
elif [ -n "$_CONTAINER_NAME" ]; then
  _MODE="container"
  # load settings
fi

case $_MODE in
  image)
    root_required
    echo "Run image... $_MACHINE $_IMG_FILE $_KERNEL $_INITRAMFS"
    if [ $_NEW_CONTAINER -eq 1 ]; then
      echo "Creating continer: $_CONTAINER_NAME"


      CONT_FILE=${CACHE_DIR}/${_CONTAINER_NAME}.img
      if [ -f $CONT_FILE ]; then
        echo "Continer already exists, launch container instead"
        exit 4
      fi

      prepare_mmc_imgfile $_IMG_FILE $CONT_FILE

      mkdir -p $DB_DIR/$_CONTAINER_NAME
      cat <<EOF > $DB_DIR/${_CONTAINER_NAME}/config.txt
# file auto-generated
container $_CONTAINER_NAME
device    $_MACHINE
kernel    $_KERNEL
initramfs $_INITRAMFS
imgboot   $_IMG_BOOT

rootimg   $_IMG_FILE
cdate     $(date)
EOF
    else
      # running tempolary container
      TEMP_CACHE_FILE=$(mktemp --tmpdir=$TEMP_DIR --suffix=-container.img)
      _CONTAINER_NAME=$(basename ${TEMP_CACHE_FILE})

      prepare_mmc_imgfile $_IMG_FILE $TEMP_CACHE_FILE
      CONT_FILE=$TEMP_CACHE_FILE
    fi

    if [ $_IMG_BOOT -eq 1 ]; then
      # mount boot partition
      mount_boot $CONT_FILE

      _KERNEL=${BOOT_MNT_DIR}/${_KERNEL}

      if [ -f ${BOOT_MNT_DIR}/cmdline.txt ]; then
        CMDLINE_FILE_PATH=${BOOT_MNT_DIR}/cmdline.txt
      fi

      if [ -n "${_INITRAMFS}" ]; then
        _INITRAMFS=$BOOT_MNT_DIR/$_INITRAMFS
      fi
    fi

    # installation
    if [ $_NEW_CONTAINER -eq 1 ]; then
      $RUN cp $_KERNEL $DB_DIR/$_CONTAINER_NAME/
      _KERNEL=${DB_DIR}/${_CONTAINER_NAME}/$(basename ${_KERNEL})

      if [ -n "${CMDLINE_FILE_PATH}" ]; then
        $RUN cp ${CMDLINE_FILE_PATH} ${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt
        CMDLINE_FILE_PATH=${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt
      fi

      if [ -n "$_INITRAMFS" ]; then
        $RUN cp $_INITRAMFS $DB_DIR/$_CONTAINER_NAME/
        _INITRAMFS=$DB_DIR/$_CONTAINER_NAME/$(basename ${_INITRAMFS})
      fi
    fi

    if [ $_NEW_CONTAINER -eq 1 ] && [ $_IMG_BOOT -eq 1 ]; then
      # umount boot partition
      umount_boot
    fi

    # create external storage for container:
    prepare_usbstick ${EXTSTORE_DIR}/${_CONTAINER_NAME}-01.img 512
  ;;

  container)
    root_required
    echo "Run container... $_MACHINE $_IMG_FILE $_KERNEL $_INITRAMFS"

    _MACHINE=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^device'))
    _IMG_BOOT=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^imgboot'))
    _KERNEL=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^kernel'))
    _INITRAMFS=$(second_arg $(cat $DB_DIR/${_CONTAINER_NAME}/config.txt | grep '^initramfs'))

    _KERNEL=$DB_DIR/${_CONTAINER_NAME}/$_KERNEL

    if [ -n "$_INITRAMFS" ]; then
      _INITRAMFS=$DB_DIR/${_CONTAINER_NAME}/$_INITRAMFS
    fi

    CONT_FILE=${CACHE_DIR}/${_CONTAINER_NAME}.img

    if [ $_IMG_BOOT -eq 1 ]; then
      mount_boot ${CONT_FILE}

      if ! $(cmp $BOOT_MNT_DIR/$(basename ${_KERNEL}) $_KERNEL); then
        # update kernel:
        $RUN cp $BOOT_MNT_DIR/$(basename ${_KERNEL}) ${_KERNEL}
      fi

      if [ -n "${_INITRAMFS}" ] && ! $(cmp $BOOT_MNT_DIR/$(basename ${_INITRAMFS}) ${_INITRAMFS}); then
        $RUN cp $BOOT_MNT_DIR/$(basename ${_INITRAMFS}) ${_INITRAMFS}
      fi

      umount_boot
    fi
  ;;
  list)
    if [ $_LIST_WITH_DETAILS -eq 1 ]; then
      ls -lh $DB_DIR
    else
      ls $DB_DIR
    fi

    exit 0
  ;;
  *)
    # if undefined mode print help:
    print_help
    exit 2
  ;;
esac

# test and run
if [ -z $RUN ] && [ ! -f $_KERNEL ]; then
  echo "Can't find kernel: $_KERNEL"
  exit 3
fi

if [ -n "${_INITRAMFS}" ] && [ ! -f "${_INITRAMFS}" ]; then
  echo "Initramfs file does not exits ar is not available"
  exit 3
fi

M_CPU=${devices_cpu[${_MACHINE}]}
M_DTB=${devices_dtb[${_MACHINE}]}

DTB_FILE=${DTB_LIB}/${M_DTB}

if [ ! -f "${DTB_FILE}" ]; then
  echo "DTB file has not been found: ${DTB_FILE}"
  exit 3
fi

#   -chardev socket,id=com0,path=/tmp/builder1.sock,server=on,wait=off \
# mount /dev/loop1p2 /mnt/dir
# cd /mnt/dir
# rm ./systemd/system/multi-user.target.wants/userconfig.service
#

# PCI required:
#   -virtfs local,path=./share,mount_tag=host0,security_model=passthrough,id=host0 \

# looks like system does not create /dev/ttyAMA0 device,
# as a result only boot messages are print, can't login
# All (Ethernet and mass storage) USB devices running at USB 1.1 speed
# slow, but works well and no rush
function run() {
  KERNEL_LINE="-kernel ${_KERNEL}"

  # add initrd if its used
  if [ -n "${_INITRAMFS}" ]; then
    KERNEL_LINE="${KERNEL_LINE} -initrd ${_INITRAMFS}"
  fi

  if [ ! -f "${CMDLINE_FILE_PATH}" ] && [ -f "${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt" ]; then
    CMDLINE_FILE_PATH=${DB_DIR}/${_CONTAINER_NAME}/cmdline.txt

    KERNEL_PARAMS=$(tail -n 1 "${CMDLINE_FILE_PATH}")
  else
    # default kernel parameters
    KERNEL_PARAMS="console=tty1 console=ttyAMA0 root=/dev/mmcblk0p2 rw"
    # console=ttyAMA1

    # Set parameters
    if [ ${_NO_PART_TABLE_MODE} -eq 0 ]; then
      KERNEL_PARAMS="${KERNEL_PARAMS} root=/dev/mmcblk0p2 rw"
    else
      KERNEL_PARAMS="${KERNEL_PARAMS} modules=loop,squashfs,sd-mod,usb-storage"
    fi
  fi

  $RUN /usr/bin/qemu-system-aarch64 \
    -M ${_MACHINE} \
    -cpu ${M_CPU} -m 1024 \
    -monitor unix:$QEMU_MONITOR_UNIXSOCKET,server,nowait \
    -serial pty \
    ${KERNEL_LINE} -append "${KERNEL_PARAMS}" \
    -drive id=sysdrive,if=none,format=raw,file=${CONT_FILE} \
    -device sd-card,drive=sysdrive \
    -usb \
    -device usb-kbd,bus=usb-bus.0 \
    -netdev user,id=net0,hostfwd=tcp::15022-:22 \
    -device usb-net,bus=usb-bus.0,netdev=net0 \
    -dtb ${DTB_FILE} \
    -rtc base=localtime \
    -name "$_MACHINE emulator"

    #     -drive id=imgout0,if=none,format=raw,file="${EXTSTORE_DIR}/${_CONTAINER_NAME}-01.img" \
    #      -device usb-storage,bus=usb-bus.0,drive=imgout0 \
}

function insert_usbstick() {
  local PATH=$1

  nc -U $QEMU_MONITOR_UNIXSOCKET -q 0 <<EOF
info usb
EOF
#  drive_add 0 if=none,id=usbdrive1,format=raw,file=$PATH
#  device_add usb-storage,drive=usbdrive1,bus=usb-bus.0

  # do stuff

  device_del usbdrive1
}

run

if [ -n "$TEMP_CACHE_FILE" ] && [ -e "$TEMP_CACHE_FILE" ]; then
  $RUN rm "$TEMP_CACHE_FILE"
  $RUN rm ${EXTSTORE_DIR}/${_CONTAINER_NAME}-01.img

  if [ $_IMG_BOOT -eq 1 ]; then
    $RUN umount_boot
  fi
fi


exit 0
